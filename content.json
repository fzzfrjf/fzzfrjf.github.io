{"meta":{"title":"fzzf","subtitle":"fzzfの博客","description":"慢慢学习","author":"fzzf","url":"http://fzzfrjf.github.io","root":"/"},"pages":[{"title":"","date":"2022-03-28T02:56:10.742Z","updated":"2022-03-28T02:56:02.160Z","comments":true,"path":"artitalk/index.html","permalink":"http://fzzfrjf.github.io/artitalk/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2020-04-19T04:58:56.000Z","updated":"2022-03-28T02:55:33.028Z","comments":false,"path":"about/index.html","permalink":"http://fzzfrjf.github.io/about/index.html","excerpt":"","text":"fzzfのthought“ 小小的鸡汤 “ 当你在项目中感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在项目中不断获得了友谊和朋友时，说明你将取得项目的 成功 。 联系我B站：fzzf1017（萌新up） QQ：1063131130 （嘀嘀~，麻烦让一下，我要开车了！） 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-03-28T02:55:48.112Z","comments":true,"path":"archives/index.html","permalink":"http://fzzfrjf.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2022-03-28T02:56:20.754Z","comments":false,"path":"categories/index.html","permalink":"http://fzzfrjf.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2022-03-28T02:56:58.699Z","comments":true,"path":"link/index.html","permalink":"http://fzzfrjf.github.io/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2022-03-28T02:56:32.316Z","comments":false,"path":"comments/index.html","permalink":"http://fzzfrjf.github.io/comments/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"http://fzzfrjf.github.io/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"http://fzzfrjf.github.io/tags/index.html","excerpt":"","text":""},{"title":"Music-BBOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-03-28T03:03:55.370Z","comments":false,"path":"List/music/index.html","permalink":"http://fzzfrjf.github.io/List/music/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-03-28T02:57:24.761Z","comments":false,"path":"List/movies/index.html","permalink":"http://fzzfrjf.github.io/List/movies/index.html","excerpt":"","text":"励志视频"},{"title":"","date":"2021-09-28T14:56:13.000Z","updated":"2021-10-14T02:11:35.135Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"http://fzzfrjf.github.io/List/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-28T02:57:13.230Z","updated":"2022-03-28T02:57:13.230Z","comments":false,"path":"List/gallery/index.html","permalink":"http://fzzfrjf.github.io/List/gallery/index.html","excerpt":"","text":"壁紙 世俗的欲望 圣嘉然 關於圣嘉然的圖片"},{"title":"","date":"2021-09-28T14:56:14.000Z","updated":"2022-03-27T08:08:26.935Z","comments":false,"path":"List/gallery/shengjiaran/index.html","permalink":"http://fzzfrjf.github.io/List/gallery/shengjiaran/index.html","excerpt":"","text":""}],"posts":[{"title":"牛客NC3 链表中环的入口结点","slug":"06-寻找链表环入口结点","date":"2022-04-06T15:03:00.000Z","updated":"2022-04-06T15:15:01.685Z","comments":true,"path":"posts/5.html","link":"","permalink":"http://fzzfrjf.github.io/posts/5.html","excerpt":"","text":"牛客NC3 链表中环的入口结点题目如下： 主要思想就是首先利用快慢指针判断是否有环，如果有环，再根据下面的思想让快指针重头开始走，慢指针继续走，走到相遇就是环入口结点的地方： 代码如下： public class Solution { public ListNode EntryNodeOfLoop(ListNode pHead) { ListNode ft = pHead; ListNode fast = pHead; ListNode slow = pHead; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow){ while(slow != ft){ slow = slow.next; ft = ft.next; } return ft; } } return null; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://fzzfrjf.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"解法","slug":"解法","permalink":"http://fzzfrjf.github.io/tags/%E8%A7%A3%E6%B3%95/"},{"name":"链表环","slug":"链表环","permalink":"http://fzzfrjf.github.io/tags/%E9%93%BE%E8%A1%A8%E7%8E%AF/"}]},{"title":"Leetcode37题，解数独","slug":"05-填数组","date":"2022-03-29T05:30:00.000Z","updated":"2022-03-29T05:36:58.359Z","comments":true,"path":"posts/5.html","link":"","permalink":"http://fzzfrjf.github.io/posts/5.html","excerpt":"","text":"Leetcode37:解数独编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 主要思想的话就是先创建三个数组来存储每一列每一行每一个块这个字符出现的情况，遍历数独，将每个位置存在的数存入数组，将’.’所在的行列存入一个数组集合。之后调用递归，来对每一个’.’位置的字符进行尝试，如果尝试失败，则进行回溯。题解如下：class Solution { private boolean[][] row = new boolean[9][9]; private boolean[][] col = new boolean[9][9]; private boolean[][][] block = new boolean[3][3][9]; private boolean valid = false; private List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); public void solveSudoku(char[][] board) { for(int i = 0; i &lt; 9;i++){ for(int j = 0;j &lt; 9; j++){ if(board[i][j] == '.') list.add(new int[]{i,j}); else{ int digit = board[i][j] - '0' - 1; row[i][digit] = col[j][digit] = block[i/3][j/3][digit] = true; } } } dfs(board,0); } public void dfs(char[][] board,int num){ if(num == list.size()){ valid = true; return; } int[] temp = list.get(num); int i = temp[0] , j = temp[1]; for(int n = 0;n &lt; 9 &amp;&amp; !valid ;n++){ if(!row[i][n] &amp;&amp; !col[j][n] &amp;&amp; !block[i/3][j/3][n]){ row[i][n] = col[j][n] = block[i/3][j/3][n] = true; board[i][j] = (char)(n + '0' + 1); dfs(board,num+1); row[i][n] = col[j][n] = block[i/3][j/3][n] = false; } } } }","categories":[{"name":"算法","slug":"算法","permalink":"http://fzzfrjf.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"解法","slug":"解法","permalink":"http://fzzfrjf.github.io/tags/%E8%A7%A3%E6%B3%95/"},{"name":"数独","slug":"数独","permalink":"http://fzzfrjf.github.io/tags/%E6%95%B0%E7%8B%AC/"}]},{"title":"Leetcode34题，寻找子元素位置","slug":"04-在排序数组寻找元素的第一个和最后一个位置","date":"2022-03-29T02:37:00.000Z","updated":"2022-03-29T02:46:03.157Z","comments":true,"path":"posts/4.html","link":"","permalink":"http://fzzfrjf.github.io/posts/4.html","excerpt":"","text":"Leetcode34:在排序数组中查找元素的第一个位置和最后一个位置给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。要求时间复杂度为logn。 主要思想的话就是寻找大于等于target值在数组中出现的位置，之后再寻找target+1出现的位置，进行判断即可，题解如下：class Solution { public int[] searchRange(int[] nums, int target) { int l = searchBinary(nums,target); int r = searchBinary(nums,target + 1); if(l == nums.length || nums[l] != target){ return new int[]{-1,-1}; } return new int[]{l,r - 1}; } public int searchBinary(int[] nums,int target){ int len = nums.length; int l = 0; int r = len; while(l &lt; r){ int mid = (l + r) &gt;&gt; 1; if(nums[mid] &gt;= target){ r = mid; }else{ l = mid + 1; } } return l; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://fzzfrjf.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"解法","slug":"解法","permalink":"http://fzzfrjf.github.io/tags/%E8%A7%A3%E6%B3%95/"},{"name":"子数组","slug":"子数组","permalink":"http://fzzfrjf.github.io/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"}]},{"title":"KMP算法","slug":"03-KMP算法","date":"2022-03-27T15:03:00.000Z","updated":"2022-03-28T07:38:35.934Z","comments":true,"path":"posts/3.html","link":"","permalink":"http://fzzfrjf.github.io/posts/3.html","excerpt":"","text":"KMP算法指的是字符串模式匹配算法，问题是：在主串T中找到第一次出现完整子串P时的起始位置。kpm算法看了几天勉强看懂，但是过了几天就完全忘了当时怎么想的，所以直接背吧！ class Kmp{ public int findSubString(String t,String p){ int[] next = getNext(p); for(int i = 0, j = 0; i &lt; t.length();i++){ while(j &gt; 0 &amp;&amp; p.charAt(i) != p.charAt(j)) j = next[j - 1]; if(p.charAt(i) == p.charAt(j)) j++; if(j == p.length()) return i - j + 1; } return -1; } public int[] getNext(String p){ int[] next = new int[p.length()]; next[0] = 0; for(int i = 1,j = 0; i &lt; p.length();i++){ while(j &gt; 0 &amp;&amp; p.charAt(i) != p.charAt(j)) j = next[j - 1]; if(p.charAt(i) == p.charAt(j)) j++; next[i] = j; } return next; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://fzzfrjf.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"解法","slug":"解法","permalink":"http://fzzfrjf.github.io/tags/%E8%A7%A3%E6%B3%95/"}]},{"title":"寻找下一个更大序列","slug":"02-寻找下一个大序列数组","date":"2022-03-27T13:37:00.000Z","updated":"2022-03-28T07:37:00.880Z","comments":true,"path":"posts/2.html","link":"","permalink":"http://fzzfrjf.github.io/posts/2.html","excerpt":"","text":"题目：整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。给你一个整数数组 nums ，找出 nums 的下一个排列。 必须 原地 修改，只允许使用额外常数空间。 来源：力扣（LeetCode） 主要思想就是倒序寻找一个与前面数相邻是大的数（比如nums[i] &gt; nums[i - 1]）此时为了保证交换后的数组是变大了，但是变得不是那么大，可以用此大数前边的较小数去与大数后边的序列的最小数（但是必须大于nums[i - 1]）交换，代码如下。class Solution { public void nextPermutation(int[] nums) { int len = nums.length; for(int i = len - 1;i &gt; 0; i--){ if(nums[i] &gt; nums[i - 1]){ Arrays.sort(nums,i,len); for(int j = i; j &lt; len;j++){ if(nums[j] &gt; nums[i - 1]){ int temp = nums[i - 1]; nums[i - 1] = nums[j]; nums[j] = temp; return; } } } } Arrays.sort(nums); return; } }","categories":[{"name":"算法","slug":"算法","permalink":"http://fzzfrjf.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"解法","slug":"解法","permalink":"http://fzzfrjf.github.io/tags/%E8%A7%A3%E6%B3%95/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-03-26T13:19:00.000Z","updated":"2022-03-26T13:20:25.783Z","comments":true,"path":"posts/1.html","link":"","permalink":"http://fzzfrjf.github.io/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？肿么说了! 纯属个人兴趣，好玩，唉，就是玩!嘻嘻! 会有些成就感吧,拥有一个自己的博客写一些自己感兴趣的事或物,不是一件很酷的事嘛! 展望博客我会整理一些个人所学的知识（java的学习过程以及以后学习到新的技术栈）或生活方面有兴趣的事发到博客上供大家观摩，后边找工作时也会分享一些找工作的经验。 关于博主风中追风，是我一直比较喜欢的一个词语，希望在一生不断前进的道路上，能够乘风而行，不懈怠丝毫，一直向前进，风中追风！ 《自由与爱情》---作者:裴多菲 ​ 生命诚可贵 ​ 爱情价更高 ​ 若为自由故 ​ 二者皆可抛 溜溜球啦！","categories":[{"name":"生活","slug":"生活","permalink":"http://fzzfrjf.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"http://fzzfrjf.github.io/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"http://fzzfrjf.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","permalink":"http://fzzfrjf.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"解法","slug":"解法","permalink":"http://fzzfrjf.github.io/tags/%E8%A7%A3%E6%B3%95/"},{"name":"链表环","slug":"链表环","permalink":"http://fzzfrjf.github.io/tags/%E9%93%BE%E8%A1%A8%E7%8E%AF/"},{"name":"数独","slug":"数独","permalink":"http://fzzfrjf.github.io/tags/%E6%95%B0%E7%8B%AC/"},{"name":"子数组","slug":"子数组","permalink":"http://fzzfrjf.github.io/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"},{"name":"想法","slug":"想法","permalink":"http://fzzfrjf.github.io/tags/%E6%83%B3%E6%B3%95/"}]}